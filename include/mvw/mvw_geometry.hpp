#ifndef _MVW_GEOMETRY_HPP_
#define _MVW_GEOMETRY_HPP_

#include <shadertoy.hpp>

#include <map>
#include <string>
#include <optional>
#include <variant>

#include "mvw/vertex_data.hpp"

typedef std::variant<int> hint_value;

#define HINT_NOSCALE "noscale"
#define HINT_NOLIGHT "nolight"

// Base class for geometry loaded by the mvw library
class mvw_geometry : public shadertoy::geometry::basic_geometry {
    // Provide subclasses direct access to the geometry fields
    struct mvw_mesh {
        std::unique_ptr<shadertoy::backends::gx::vertex_array> vao;
        std::unique_ptr<shadertoy::backends::gx::buffer> vertices;
        std::unique_ptr<shadertoy::backends::gx::buffer> indices;
        size_t indices_size;

        mvw_mesh();
    };

    /// Default VAO: actually unused
    std::unique_ptr<shadertoy::backends::gx::vertex_array> vao_;

    /// List of meshes to render
    std::vector<mvw_mesh> meshes_;

    /// List of hints generated by the geometry for the viewer
    std::map<std::string, hint_value> hints_;

   protected:
    glm::vec3 bbox_min_;
    glm::vec3 bbox_max_;
    glm::dvec3 bbox_centroid_;

    mvw_geometry();

    void add_vertex_data(const std::vector<vertex_data> &vertices,
                         const std::vector<uint32_t> &indices);

    void set_hint(const std::string &hint, hint_value value = 1);

   public:
    inline const std::unique_ptr<shadertoy::backends::gx::vertex_array> &vertex_array() const {
        return vao_;
    }

    inline void get_dimensions(glm::vec3 &bbox_min, glm::vec3 &bbox_max) const {
        bbox_min = bbox_min_;
        bbox_max = bbox_max_;
    }

    inline glm::dvec3 get_centroid() const { return bbox_centroid_; }

    void draw() const override;

    bool has_hint(const std::string &hint) const;
    std::optional<hint_value> hint_val(const std::string &hint) const;
};

#endif /* _MVW_GEOMETRY_HPP_ */
